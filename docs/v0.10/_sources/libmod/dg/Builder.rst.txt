.. _cpp-dg/Builder:

**********************************************************
dg/Builder.hpp
**********************************************************
.. default-domain:: cpp
.. default-role:: cpp:expr

.. py:currentmodule:: mod
.. cpp:namespace:: mod


Class ``dg::Builder``
--------------------------------------------------------------------------------------------------------------------------------

.. class:: dg::Builder
    

    An RAII-style object obtained from :cpp:func:`DG::build`.
    On destruction of an active builder object the owning :cpp:class:`DG` will be locked
    for further modifications.
    Builder objects are move-only types, and a moved from object becomes an inactive builder,
    not associated with any :cpp:class:`DG`.


Synopsis
^^^^^^^^

.. code-block:: c++
    
    class MOD_DECL Builder {
        friend class DG;
        explicit Builder(lib::DG::NonHyperBuilder &dg_);
    public:
        Builder(Builder &&other);
        Builder &operator=(Builder &&other);
        ~Builder();
        bool isActive() const;
    public:
        DG::HyperEdge addDerivation(const Derivations &d);
        DG::HyperEdge addDerivation(const Derivations &d, IsomorphismPolicy graphPolicy);
        ExecuteResult execute(std::shared_ptr<Strategy> strategy);
        ExecuteResult execute(std::shared_ptr<Strategy> strategy, int verbosity);
        ExecuteResult execute(std::shared_ptr<Strategy> strategy, int verbosity, bool ignoreRuleLabelTypes);
        void addAbstract(const std::string &description);
    private:
        struct Pimpl;
        std::unique_ptr<Pimpl> p;
    };

Details
^^^^^^^

.. cpp:namespace-push:: dg::Builder

.. function:: bool isActive() const

    :returns: whether this object is associated with a :cpp:class:`DG`.
.. function:: DG::HyperEdge addDerivation(const Derivations &d)
              DG::HyperEdge addDerivation(const Derivations &d, IsomorphismPolicy graphPolicy)

    Adds a hyperedge corresponding to the given derivation to the associated :class:`DG`.
    If it already exists, only add the given rules to the edge.
    The given :var:`graphPolicy` refers to adding the graphs in :var:`d`,
    and it defaults to :enumerator:`IsomorphismPolicy::Check`.

    :returns: the hyperedge corresponding to the given derivation.
    :throws: :class:`LogicError` if `!isActive()`.
    :throws: :class:`LogicError` if `d.left.empty()`.
    :throws: :class:`LogicError` if `d.right.empty()`.
    :throws: :class:`LogicError` if `graphPolicy == IsomorphismPolicy::Check` and a given graph object
        is different but isomorphic to another given graph object or to a graph object already
        in the internal graph database in the associated derivation graph.
.. function:: ExecuteResult execute(std::shared_ptr<Strategy> strategy)
              ExecuteResult execute(std::shared_ptr<Strategy> strategy, int verbosity)
              ExecuteResult execute(std::shared_ptr<Strategy> strategy, int verbosity, bool ignoreRuleLabelTypes)

    Execute the given strategy (:ref:`dgStrat`) and as a side-effect add
    vertices and hyperedges to the underlying derivation graph.

    The :cpp:var:`verbosity` defaults to level 2.
    The levels have the following meaning:

    - 0 (or less): no information is printed.
    - 2: Repetition strategies print information for each round.
    - 4: All strategies print minimal information.
    - 6: Derivation predicate strategies and filtering strategies also print their predicates.
    - 8: Rule strategies print minimal information about graph binding.
    - 10: Rule strategies print more information about graph binding, including failure due to derivation predicates.
    - 50: Print information about morphism generation for rule composition.
    - 60: Print rule composition information.

    :throws: :class:`LogicError` if a static "add" strategy has `IsomorphismPolicy::Check` as graph policy,
        and it tries to add a graph object isomorphic to an already known, but different, graph object in the database.
        This is checked before execution, so there is strong exception guarantee.
    :throws: :class:`LogicError` if a dynamic "add" strategy has `IsomorphismPolicy::Check` as graph policy,
        and it tries to add a graph object isomorphic to an already known, but different, graph object in the database.

        .. warning:: This is checked during execution, so while the basic exception guarantee is provided,
            there may be modifications to the underlying derivation graph.
    :throws: :class:`LogicError`: if `ignoreRuleLabelTypes` is `false`, which is the default,
        and a rule in the given strategy has an associated :enum:`LabelType` which is different from the one
        in the derivation graph.
.. function:: void addAbstract(const std::string &description)

    Add vertices and hyperedges based on the given abstract description.
    The description must adhere to the grammar described at :ref:`dg_abstract-desc`.

    For each vertex named in the description a graph object with no vertices will be created,
    and its name set to the given identifier.

    :throws: :class:`InputError` if the description could not be parsed.

.. cpp:namespace-pop::


Class ``dg::ExecuteResult``
--------------------------------------------------------------------------------------------------------------------------------

.. class:: dg::ExecuteResult
    

    The result from calling :func:`Builder::execute`.


Synopsis
^^^^^^^^

.. code-block:: c++
    
    class MOD_DECL ExecuteResult {
        friend class Builder;
        explicit ExecuteResult(std::shared_ptr<DG> dg_, lib::DG::ExecuteResult innerRes);
    public:
        ExecuteResult(ExecuteResult &&other);
        ExecuteResult &operator=(ExecuteResult &&other);
        ~ExecuteResult();
        const std::vector<std::shared_ptr<graph::Graph>> &getSubset() const;
        const std::vector<std::shared_ptr<graph::Graph>> &getUniverse() const;
        void list(bool withUniverse) const;
    private:
        struct Pimpl;
        std::unique_ptr<Pimpl> p;
    };

Details
^^^^^^^

.. cpp:namespace-push:: dg::ExecuteResult

.. function:: const std::vector<std::shared_ptr<graph::Graph>> &getSubset() const
              const std::vector<std::shared_ptr<graph::Graph>> &getUniverse() const

    :returns: respectively the subset and the universe computed by the strategy execution (see also :ref:`dgStrat`).
.. function:: void list(bool withUniverse) const

    Output information from the execution of the strategy.
    The universe lists can be rather long so with `withUniverse == false` they are omitted.

.. cpp:namespace-pop::

