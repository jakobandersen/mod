import enum
from typing import Callable, Iterable, List, Optional, overload, Tuple, TypeVar, Union

T = TypeVar("T")
U = TypeVar("U")


#-----------------------------------------------------------------------------
# Meta
#-----------------------------------------------------------------------------

# Collection
#-----------------------------------------------------------------------------

class Vec(List[T]): ...

class _VecDGHyperEdge(Vec[DG.HyperEdge]): ...
class _VecDGVertex(Vec[DG.Vertex]): ...
class _VecDGStrat(Vec[DGStrat]): ...
class _VecGraph(Vec[Graph]): ...
class _VecRCExpExp(Vec[RCExpExp]): ...
class _VecRule(Vec[Rule]): ...


# Function
#-----------------------------------------------------------------------------

class _Func_VecGraph:
	def __call__(self) -> Vec[Graph]: ...
class _Func_String:
	def __call__(self) -> str: ...

class _Func_BoolDerivation:
	def __call__(self, d: Derivation) -> bool: ...

class _Func_StringDG:
	def __call__(self, v: DG) -> str: ...

class _Func_VoidDGVertex:
	def __call__(self, v: DG.Vertex) -> None: ...
class _Func_BoolDGVertex:
	def __call__(self, v: DG.Vertex) -> bool: ...
class _Func_StringDGVertex:
	def __call__(self, v: DG.Vertex) -> str: ...
class _Func_PairDoubleBoolDGVertex:
	def __call__(self, v: DG.Vertex) -> Tuple[float, bool]: ...

class _Func_StringDGVertexInt:
	def __call__(self, v: DG.Vertex, dupNum: int) -> str: ...

class _Func_VoidDGHyperEdge:
	def __call__(self, e: DG.HyperEdge) -> None: ...
class _Func_BoolDGHyperEdge:
	def __call__(self, e: DG.HyperEdge) -> bool: ...
class _Func_StringDGHyperEdge:
	def __call__(self, e: DG.HyperEdge) -> str: ...
class _Func_PairDoubleBoolDGHyperEdge:
	def __call__(self, e: DG.HyperEdge) -> Tuple[float, bool]: ...

class _Func_BoolGraph:
	def __call__(self, g: Graph) -> bool: ...
class _Func_IntGraph:
	def __call__(self, g: Graph) -> int: ...

class _Func_StringGraphDGBool:
	def __call__(self, g: Graph, dg: DG, first: bool) -> str: ...

class _Func_BoolGraphDGStratGraphStateBool:
	def __call__(self, g: Graph, gs: DGStrat.GraphState, first: bool) -> bool: ...

class _Func_VoidDGStratGraphState:
	def __call__(self, gs: DGStrat.GraphState) -> None: ...


#-----------------------------------------------------------------------------
# Top-level non-meta
#-----------------------------------------------------------------------------

# Chem
#-----------------------------------------------------------------------------

class BondType(enum.Enum):
	Invalid = ...
	Single = ...
	Aromatic = ...
	Double = ...
	Triple = ...
def _bondTypeToString(self: BondType) -> str: ...


# Config
#-----------------------------------------------------------------------------

class LabelType(enum.Enum):
	String = ...
	Term = ...
def _LabelType__str__(self: LabelType) -> str: ...

class LabelRelation(enum.Enum):
	Isomorphism = ...
	Specialisation = ...
	Unification = ...
def _LabelRelation__str__(self: LabelRelation) -> str: ...

class LabelSettings:
	@overload
	def __init__(self, lt: LabelType, lr: LabelRelation) -> None: ...
	@overload
	def __init__(self, lt: LabelType, lr: LabelRelation, slr: LabelRelation) -> None: ...

class IsomorphismPolicy(enum.Enum):
	Check = ...
	TrustMe = ...
def _IsomorphismPolicy__str__(self: IsomorphismPolicy) -> str: ...

class SmilesClassPolicy(enum.Enum):
	NoneOnDuplicate = ...
	ThrowOnDuplicate = ...
	MapUnique = ...
def _SmilesClassPolicy__str__(self: SmilesClassPolicy) -> str: ...

class MDLOptions: ...


class Config:
	class Common:
		def __init__(self) -> None:
			self.ignoreDeprecation: bool=...

	def __init__(self) -> None:
		self.common = Config.Common()

def getConfig() -> Config: ...


# Error
#-----------------------------------------------------------------------------

class LogicError(Exception): ...


# Derivation
#-----------------------------------------------------------------------------

class Derivation: ...
class Derivations: ...


# Misc
#-----------------------------------------------------------------------------

def rngUniformReal() -> float: ...


#-----------------------------------------------------------------------------
# dg
#-----------------------------------------------------------------------------

class DG:
	def __init__(self, *, labelSettings: LabelSettings=...,
		graphDatabase: Iterable[Graph]=...,
		graphPolicy: IsomorphismPolicy=...) -> None: ...
	def findVertex(self, g: Graph) -> DG.Vertex: ...
	@overload
	def findEdge(self, sources: List[DG.Vertex], targets: List[DG.Vertex]) -> DG.HyperEdge: ...
	@overload
	def findEdge(self, sourcesGraphs: List[Graph], targetGraphs: List[Graph]) -> DG.HyperEdge: ...
	def build(self,
		onNewVertex: Optional[Callable[[DG.Vertex], None]]=None,
		onNewHyperEdge: Optional[Callable[[DG.HyperEdge], None]]=None): ...
	def print(self, printer: DGPrinter=..., data: Optional[DGPrintData]=...) -> Tuple[str, str]: ...
	@staticmethod
	def load(graphDatabase: List[Graph], ruleDatabase: List[Rule], file: str, graphPolicy: IsomorphismPolicy=..., verbosity: int=...) -> DG: ...

	class Vertex:
		graph: Graph

	class HyperEdge:
		def print(self, printer: GraphPrinter=..., nomatchColour: str=..., matchColour: str=...) -> List[Tuple[str, str]]: ...

	class Builder:
		@property
		def dg(self) -> DG: ...
		@property
		def isActive(self) -> bool: ...
		def addDerivation(self, d: Derivations, graphPolicy: IsomorphismPolicy=...) -> DG.HyperEdge: ...
		def addHyperEdge(self, e: DG.HyperEdge, graphPolicy: IsomorphismPolicy=...) -> DG.HyperEdge: ...
		def execute(self, strategy: DGStrat, *, verbosity: int=..., ignoreRuleLabelTypes: bool=...) -> ExecuteResult: ...
		def apply(self, graphs: List[Graph], rule: Rule, onlyProper: bool=..., verbosity: int=..., graphPolicy: IsomorphismPolicy=...) -> List[DG.HyperEdge]: ...
		def addAbstract(self, description: str) -> AddAbstractResult: ...
		def load(self, ruleDatabase: List[Rule], file: str, verbosity: int=...) -> None: ...

		class ExecuteResult:
			def list(self, *, withUniverse: bool=...) -> None: ...

		class AddAbstractResult:
			def getGraph(self, name: str) -> Optional[Graph]: ...


class DGPrinter:
	def pushVertexVisible(self, f: Union[Callable[[DG.Vertex], bool], bool]) -> None: ...
	def pushEdgeVisible(self, f: Union[Callable[[DG.HyperEdge], bool], bool]) -> None: ...
	def pushVertexLabel(self, f: Union[Callable[[DG.Vertex], str], str]) -> None: ...
	def pushEdgeLabel(self, f: Union[Callable[[DG.HyperEdge], str], str]) -> None: ...
	def pushVertexColour(self, f: Union[Callable[[DG.Vertex], str], str], extendToEdges: bool=...) -> None: ...
	def pushEdgeColour(self, f: Union[Callable[[DG.HyperEdge], str], str]) -> None: ...
	def setRotationOverwrite(self, f: Union[Callable[[Graph], int], int]) -> None: ...
	def setMirrorOverwrite(self, f: Union[Callable[[Graph], bool], bool]) -> None: ...
	def setImageOverwrite(self, f: Union[Callable[[DG.Vertex, int], str], str]) -> None: ...


class DGPrintData:
	def __init__(self, dg: DG) -> None: ...


class DGStrat:
	class GraphState: ...

	def __rshift__(self, other: DGStrat) -> DGStrat: ...
	def __rrshift__(self, other: DGStrat) -> DGStrat: ...

	@staticmethod
	def makeAddStatic(onlyUniverse: bool, graphs: List[Graph], graphPolicy: IsomorphismPolicy) -> DGStrat: ...
	@staticmethod
	def makeAddDynamic(onlyUniverse: bool, graphsFunc: Callable[[], List[Graph]], graphPolicy: IsomorphismPolicy) -> DGStrat: ...
	@staticmethod
	def makeSequence(strats: List[DGStrat]) -> DGStrat: ...
	@staticmethod
	def makeParallel(strats: List[DGStrat]) -> DGStrat: ...
	@staticmethod
	def makeFilter(alsoUniverse: bool, p: Callable[[Graph, GraphState, bool], bool]) -> DGStrat: ...
	@staticmethod
	def makeExecute(func: Callable[[GraphState], None]) -> DGStrat: ...
	@staticmethod
	def makeRule(rule: Rule) -> DGStrat: ...
	@staticmethod
	def makeLeftPredicate(p: Callable[[Derivation], bool], strat: DGStrat) -> DGStrat: ...
	@staticmethod
	def makeRightPredicate(p: Callable[[Derivation], bool], strat: DGStrat) -> DGStrat: ...
	@staticmethod
	def makeRevive(strat: DGStrat) -> DGStrat: ...
	@staticmethod
	def makeRepeat(limit: int, strat: DGStrat) -> DGStrat: ...


#-----------------------------------------------------------------------------
# graph
#-----------------------------------------------------------------------------

class Graph:
	name: str

	def aut(self, labelSettings: LabelSettings=...) -> GraphAutGroup: ...
	@overload
	def print(self) -> Tuple[str, str]: ...
	@overload
	def print(self, first: GraphPrinter, second: Optional[GraphPrinter]=...) -> Tuple[str, str]: ...
	def getGMLString(self, withCoords: bool=...) -> str: ...
	def printGML(self, withCoords: bool=...) -> str: ...
	def isomorphism(self, host: Graph, maxNumMatches: int=..., labelSettings: LabelSettings=...) -> int: ...
	def monomorphism(self, host: Graph, maxNumMatches: int=..., labelSettings: LabelSettings=...) -> int: ...

	@staticmethod
	def fromGMLString(     s: str, printStereoWarnings: bool=...) -> Graph: ...
	@staticmethod
	def fromGMLFile(       f: str, printStereoWarnings: bool=...) -> Graph: ...
	@staticmethod
	def fromGMLStringMulti(s: str, printStereoWarnings: bool=...) -> List[Graph]: ...
	@staticmethod
	def fromGMLFileMulti(  f: str, printStereoWarnings: bool=...) -> List[Graph]: ...

	@staticmethod
	def fromDFS(           s: str) -> Graph: ...
	@staticmethod
	def fromDFSMulti(      s: str) -> List[Graph]: ...

	@staticmethod
	def fromSMILES(        s: str, allowAbstract: bool=..., classPolicy: SmilesClassPolicy=..., printStereoWarnings: bool=...) -> Graph: ...
	@staticmethod
	def fromSMILESMulti(   s: str, allowAbstract: bool=..., classPolicy: SmilesClassPolicy=..., printStereoWarnings: bool=...) -> List[Graph]: ...

	@staticmethod
	def fromMOLString(     s: str, options: MDLOptions=..., add: bool=...) -> Graph: ...
	@staticmethod
	def fromMOLFile(       f: str, options: MDLOptions=..., add: bool=...) -> Graph: ...
	@staticmethod
	def fromMOLStringMulti(s: str, options: MDLOptions=..., add: bool=...) -> List[Graph]: ...
	@staticmethod
	def fromMOLFileMulti(  f: str, options: MDLOptions=..., add: bool=...) -> List[Graph]: ...
	@staticmethod
	def fromSDString(      s: str, options: MDLOptions=..., add: bool=...) -> List[Graph]: ...
	@staticmethod
	def fromSDFile(        f: str, options: MDLOptions=..., add: bool=...) -> List[Graph]: ...
	@staticmethod
	def fromSDStringMulti( s: str, options: MDLOptions=..., add: bool=...) -> List[List[Graph]]: ...
	@staticmethod
	def fromSDFileMulti(   f: str, options: MDLOptions=..., add: bool=...) -> List[List[Graph]]: ...

	@staticmethod
	def fromRXNString(     s: str, options: MDLOptions=..., add: bool=...): ...
	@staticmethod
	def fromRXNFile(       f: str, options: MDLOptions=..., add: bool=...): ...
	@staticmethod
	def fromRXNStringMulti(s: str, options: MDLOptions=..., add: bool=...): ...
	@staticmethod
	def fromRXNFileMulti(  f: str, options: MDLOptions=..., add: bool=...): ...


class GraphAutGroup: ...


class GraphPrinter: ...


def graphGMLString(s: str) -> Graph: ...
def graphGML(f: str) -> Graph: ...
def graphDFS(s: str) -> Graph: ...
def smiles(s: str, allowAbstract: bool, classPolicy: SmilesClassPolicy) -> Graph: ...
def mdlMOLString(s: str, addHydrogens: bool) -> Graph: ...
def mdlMOL(f: str, addHydrogens: bool) -> Graph: ...
def mdlSDString(s: str, addHydrogens: bool) -> List[Graph]: ...
def mdlSD(f: str, addHydrogens: bool) -> List[Graph]: ...


#-----------------------------------------------------------------------------
# rule
#-----------------------------------------------------------------------------

class RCEvaluator:
	def __init__(self, ruleDatabase: Iterable[Rule], labelSettings: LabelSettings=...) -> None: ...
	def eval(self, exp: RCExpExp, *, verbosity: int=...) -> List[Rule]: ...


class RCExpExp: ...

class RCExpUnion(RCExpExp):
	def __init__(self, es: Vec[RCExpExp]) -> None: ...
class RCExpId(RCExpExp):
	def __init__(self, g: Graph) -> None: ...
class RCExpBind(RCExpExp):
	def __init__(self, g: Graph) -> None: ...
class RCExpUnbind(RCExpExp):
	def __init__(self, g: Graph) -> None: ...

class RCExpComposeCommon(RCExpExp):
	def __init__(self, first: RCExpExp, second: RCExpExp, discardNonchemical: bool=..., maximum: bool=..., connected: bool=..., includeEmpty: bool=...) -> None: ...

class RCExpComposeParallel(RCExpExp):
	def __init__(self, first: RCExpExp, second: RCExpExp, discardNonchemical: bool=...) -> None: ...

class RCExpComposeSub(RCExpExp):
	def __init__(self, first: RCExpExp, second: RCExpExp, discardNonchemical: bool=..., allowPartial: bool=...) -> None: ...

class RCExpComposeSuper(RCExpExp):
	def __init__(self, first: RCExpExp, second: RCExpExp, discardNonchemical: bool=..., allowPartial: bool=..., enforceConstraints: bool=...) -> None: ...


class RCMatch:
	def compose(self, *, verbose: bool=...) -> Rule: ...
	def composeAll(self, *, maximum: bool=..., verbose: bool=...) -> List[Rule]: ...


class Rule(RCExpExp):
	name: str

	@overload
	def print(self, printCombined: bool=...) -> Tuple[str, str]: ...
	@overload
	def print(self, first: GraphPrinter, second: Optional[GraphPrinter]=..., printCombined: bool=...) -> Tuple[str, str]: ...
	def getGMLString(self, withCoords: bool=...) -> str: ...
	def printGML(self, withCoords: bool=...) -> str: ...
	def isomorphism(self, host: Rule, maxNumMatches: int=..., labelSettings: LabelSettings=...) -> int: ...
	def monomorphism(self, host: Rule, maxNumMatches: int=..., labelSettings: LabelSettings=...) -> int: ...


	def __rshift__(self, other: DGStrat) -> DGStrat: ...

	@staticmethod
	def fromGMLString(s: str, invert: bool=..., printStereoWarnings: bool=...) -> Rule: ...
	@staticmethod
	def fromGMLFile(f: str, invert: bool=..., printStereoWarnings: bool=...) -> Rule: ...
	@staticmethod
	def fromDFS(s: str, invert: bool=...) -> Rule: ...
