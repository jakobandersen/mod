#include <mod/py/Common.hpp>

#include <mod/dg/VertexMapper.hpp>
#include <mod/graph/Union.hpp>
#include <mod/rule/Rule.hpp>

namespace mod::dg::Py {

void VertexMapper_doExport() {
	// rst: .. class:: DGVertexMapper
	// rst:
	// rst:		A class for enumerating vertex maps for a given :class:`DG.HyperEdge`.
	// rst:
	// rst:		For the given hyperedge, collect the graphs associated with
	// rst:		respectively the source and target vertices, and create the disjoint union of those graphs.
	// rst:		Let the result be the graphs :math:`G` and :math:`H`, available via `DGVertexMapper.left` and `DGVertexMapper.right` respectively.
	// rst:		Then each rule :math:`p = (L\leftarrow K\rightarrow R)` associated with the hyperedge,
	// rst:		generate direct derivations :math:`\require{mathtools} G\xRightarrow{p, m} H'`.
	// rst:		An isomorphism :math:`H'\rightarrow H` is then found to ensure we have generated the correct product.
	// rst:		Each result can be described in the following commutative diagram.
	// rst:
	// rst:		.. tikz:: A diagram describing each result generated by the vertex mapper.
	// rst:			A consists of a double-pushout diagram for a direct derivation :math:`G\xRightarrow{p, m} H'`
	// rst:			and an isomorphism :math:`H'\rightarrow H`.
	// rst:
	// rst:			\matrix[matrix of math nodes, row sep=4em, column sep=4em]{
	// rst:				|(L)| L		\& |(K)| K		\& |(R)| R	\\
	// rst:				|(G)| G		\& |(D)| D		\& |(H')| H\smash{'}	\& |(H)| H	\\
	// rst:			};
	// rst:			\foreach \s/\t in {K/L, K/R, K/D} {
	// rst:				\draw[->] (\s) to (\t);
	// rst:			}
	// rst:			\draw[->] (L) to node[auto] {$m$} (G);
	// rst:			\draw[->] (D) to node[above] {$g\vphantom{h}$} (G);
	// rst:			\draw[->] (D) to node[above] {$h\vphantom{g}$} (H');
	// rst:			\draw[->] (R) to node[auto] {$a$} (H');
	// rst:			\draw[->] (H') to node[auto] {$b$} (H);
	// rst:			\draw[->] (R) to node[auto] {$m' = b\circ a$} (H);
	// rst:
	// rst:		Each result is available in the form of three vertex maps:
	// rst:
	// rst:		- `Result::map` (:math:`V(G) \rightarrow V(H)`): the vertex map of the derivation,
	// rst:		  which maps vertices of the input graph :math:`G` to the product graph :math:`H`.
	// rst:		  The map is defined as the composition :math:`b\circ h\circ g^{-1}`.
	// rst:		  Note that if the rule :math:`p` either creates or removes vertices, then the map is partial.
	// rst:		  As all morphisms are injective, the vertex map is as well.
	// rst:		- `Result::match` (:math:`m\colon L\rightarrow G`): the match morphism.
	// rst:		- `Result::comatch` (:math:`m'\colon L\rightarrow H`): the comatch morphism.
	// rst:		  It is defined as the composition :math:`b\circ a`.
	// rst:
	// rst:		The vertex mapper can be configured in two ways via the constructor:
	// rst:
	// rst:		- ``upToIsomorphismGDH``: this controls which spans :math:`G\leftarrow D\rightarrow H'` and match morphisms :math:`m\colon L\rightarrow G`
	// rst:		  are enumerated. When set `true` only a single representative of the span is generated per isomorphism class.
	// rst:		- ``rightLimit``: this controls the amount of isomorphisms :math:`b\colon H'\rightarrow H` are generated.
	// rst:
	// rst:		For example:
	// rst:
	// rst:		- If you just want a single result, then use ``upToIsomorphismGDH = True`` and ``rightLimit = 1``.
	// rst:		- If you want all different vertex maps :math:`V(G)\rightarrow V(H)`,
	// rst:		  then use ``upToIsomorphismGDH = True`` and ``rightLimit`` set to some arbitrary high value, e.g., :math:`2^{30}`.
	// rst:		- If you are interested in all the different ways the rule can be matched to generate this direct derivation,
	// rst:		  but do not care about the specific vertex map :math:`V(G)\rightarrow V(H)`,
	// rst:		  then use ``upToIsomorphismGDH = False`` and ``rightLimit = 1``.
	// rst:		- And finally, if you want all possible results,
	// rst:		  then use ``upToIsomorphismGDH = False`` and set ``rightLimit`` to some high value, e.g., :math:`2^{30}`.
	// rst:
	py::scope parent = py::class_<VertexMapper, boost::noncopyable>("DGVertexMapper", py::no_init)
	                   // rst:		.. method:: __init__(e, upToIsomorphismGDH=True, rightLimit=2**30)
	                   // rst:
	                   // rst:			Construct a vertex map holder, and immediately calculate vertex maps for the derivations underlying the
	                   // rst:			given hyperedge.
	                   // rst:
	                   // rst:			:param DG.HyperEdge e: the hyperedge to construct vertex maps for.
	                   // rst:			:param bool upToIsomorphismGDH: whether to only enumerate spans :math:`G \leftarrow D\rightarrow H'` up to isomorphism, all :math:`m`, or just those such that all bottom spans
	                   // rst:				:math:`(G\leftarrow D\rightarrow H)` up to isomorphism are generated.
	                   // rst:				Defaults to ``True``.
	                   // rst:			:param int rightLimit: after bottom span generation, find this many isomorphisms back to the targets of the hyperedge.
	                   // rst:			:raises: :class:`LogicError` if ``not e``.
	                   .def(py::init<DG::HyperEdge, bool, int, int>(
	                   (py::args("upToIsomorphismGDH") = true, py::args("rightLimit") = 1 << 30,
		                   py::args("verbosity") = 0)))
	                   // rst:		.. attribute:: edge
	                   // rst:
	                   // rst:			(Read-only) The hyperedge to calculate vertex maps for.
	                   // rst:
	                   // rst:			:type: DG.HyperEdge
	                   .def_readonly("edge", &VertexMapper::getEdge)
	                   // rst:		.. attribute:: left
	                   // rst:		               right
	                   // rst:
	                   // rst:			:returns: the disjoint union of graphs from respectively the source and target vertices of the hyperedge.
	                   // rst:				That is, the graphs :math:`G` and :math:`H`.
	                   // rst:			:type: UnionGraph
	                   .def_readonly("left", &VertexMapper::getLeft)
	                   .def_readonly("right", &VertexMapper::getRight)
	                   // rst:		.. method:: __iter__()
	                   // rst:
	                   // rst:			:returns: an iterator over the vertex maps,
	                   // rst:				see :meth:`__getitem__` for the specific type.
	                   .def("__iter__", py::iterator<VertexMapper>())
	                   // rst:		.. attribute:: size
	                   // rst:
	                   // rst:			(Read-only) The number of vertex maps calculated.
	                   // rst:
	                   // rst:			:type: int
	                   .def_readonly("size", &VertexMapper::size)
	                   // rst:		.. method:: __len__()
	                   // rst:
	                   // rst:			:returns: :attr:`size`
	                   // rst:			:rtype: int
	                   .def("__len__", &VertexMapper::size)
	                   // rst:		.. method:: __getitem__(i)
	                   // rst:
	                   // rst:			:param int i: the index of the map to retrieve.
	                   // rst:			:returns: the ``i``\ th vertex map.
	                   // rst:			:rtype: Result
	                   // rst:			:raises: :class:`LogicError` if ``i`` is out of range.
	                   .def("__getitem__", &VertexMapper::operator[]);

	// rst: .. class:: DGVertexMapper.Result
	// rst:
	// rst:		The value type returned for each result.
	// rst:
	py::class_<VertexMapper::Result>("Result", py::no_init)
			// rst: 	.. attribute:: rule
			// rst:
			// rst: 		The rule used to generate the map.
			// rst:
			// rst: 		:type: Rule
			.def_readonly("rule", &VertexMapper::Result::r)
			// rst: 	.. attribute:: map
			// rst:
			// rst: 		The vertex map :math:`V(G) \rightarrow V(H)`.
			// rst:
			// rst: 		:type: VertexMapUnionGraphUnionGraph
			.def_readonly("map", &VertexMapper::Result::map)
			// rst: 	.. attribute:: match
			// rst:
			// rst: 		The vertex map :math:`V(L) \rightarrow V(G)`.
			// rst:
			// rst: 		:type: VertexMapRuleLeftGraphUnionGraph
			.def_readonly("match", &VertexMapper::Result::match)
			// rst: 	.. attribute:: comatch
			// rst:
			// rst: 		The vertex map :math:`V(R) \rightarrow V(H)`.
			// rst:
			// rst: 		:type: VertexMapRuleRightGraphUnionGraph
			.def_readonly("comatch", &VertexMapper::Result::comatch);;
}

} // namespace mod::dg::Py