#include <mod/py/Common.hpp>

#include <mod/Config.hpp>

#include <boost/mpl/vector.hpp>

namespace mod::Py {
namespace {

std::string LabelType_str(LabelType lt) {
	return boost::lexical_cast<std::string>(lt);
}

std::string LabelRelation_str(LabelRelation lr) {
	return boost::lexical_cast<std::string>(lr);
}

std::string IsomorphismPolicy_str(IsomorphismPolicy p) {
	return boost::lexical_cast<std::string>(p);
}

std::string SmilesClassPolicy_str(SmilesClassPolicy p) {
	return boost::lexical_cast<std::string>(p);
}

} // namespace

void Config_doExport() {
	// rst: .. class:: LabelType
	// rst:
	// rst:		Selector for which type of label to use in algorithms.
	// rst:
	py::enum_<LabelType>("LabelType")
			// rst:		.. attribute:: String
			// rst:
			// rst:			Vertices and edges are considered to be labelled with
			// rst:			character strings. If only first-order terms are present,
			// rst:			then strings are generated as a serialisation of the term.
			.value("String", LabelType::String)
					// rst:
					// rst:		.. attribute:: Term
					// rst:
					// rst:			Vertices and edges are considered to be labelled with
					// rst:			first-order terms. If only strings are present, then first-order
					// rst:			terms are generated by parsing the strings. This may result
					// rst:			in an :class:`TermParsingError` if a string can not be parsed.
			.value("Term", LabelType::Term);
	py::def("_LabelType__str__", &LabelType_str);

	// rst: .. class:: LabelRelation
	// rst:
	// rst:		Selector for which type of labelled morphism to use in an algorithm.
	// rst:		For strings they are all defined to be equivalent to string equality.
	// rst:
	py::enum_<LabelRelation>("LabelRelation")
			// rst:		.. attribute:: Isomorphism
			// rst:
			// rst:			Terms are considered isomorphic when their most general unifier
			// rst:			is a renaming.
			.value("Isomorphism", LabelRelation::Isomorphism)
					// rst:		.. attribute:: Specialisation
					// rst:
					// rst:			A term :math:`t_2` is more special than, or isomorphic to, a term :math:`t_1` if there is a substitution
					// rst:			which can be applied to :math: `t_1` to make the terms equal.
					// rst:			This relation means that the right-hand side of a comparison is the more specialised term.
			.value("Specialisation", LabelRelation::Specialisation)
					// rst:		.. attribute:: Unification
					// rst:
					// rst:			Terms unify if a most general unifier (MGU) exists. The found MGU
					// rst:			is used for substitution in some algorithms.
			.value("Unification", LabelRelation::Unification);
	py::def("_LabelRelation__str__", &LabelRelation_str);

	// rst: .. class:: LabelSettings
	// rst:
	// rst:		A group label settings commonly used together in algorithms.
	// rst:
	py::class_<LabelSettings>("LabelSettings", py::no_init)
			// rst:		.. method:: __init__(type, relation)
			// rst:		               __init__(type, relation, stereoRelation)
			// rst:		               __init__(type, relation, withStereo, stereoRelation)
			// rst:
			// rst:			Construct label settings that only uses at least the vertex and edge labels.
			// rst:			If ``stereoRelation`` is given but ``withStereo`` is not, then ``withStereo`` defaults to ``True``.
			// rst:
			// rst:			:param LabelType type: How to interpret labels.
			// rst:			:param LabelRelation relation: The relation that should hold in morphisms between two labels.
			// rst:			:param bool withStereo: A flag to specify if stereo information should be included.
			// rst:				Defaults to ``False``, unless ``stereoRelation`` is gieven, then ``True``.
			// rst:			:param LabelRelation stereoRelation: The relation that should hold in morphisms between stereo data.
			// rst:				Defaults to :class:`LabelRelation.Isomorphism`, but is only used when ``withStereo`` is ``True``.
			.def(py::init<LabelType, LabelRelation>())
			.def(py::init<LabelType, LabelRelation, LabelRelation>())
			.def(py::init<LabelType, LabelRelation, bool, LabelRelation>())
			.def(py::self == py::self)
			.def(py::self != py::self)
			.def(str(py::self))
					// rst:		.. attribute:: type
					// rst:
					// rst:			:type: LabelType
			.def_readwrite("type", &LabelSettings::type)
					// rst:		.. attribute:: relation
					// rst:
					// rst:			:type: LabelRelation
			.def_readwrite("relation", &LabelSettings::relation)
					// rst:		.. attribute:: withStereo
					// rst:
					// rst:			:type: bool
			.def_readwrite("withStereo", &LabelSettings::withStereo)
					// rst:		.. attribute:: stereoRelation
					// rst:
					// rst:			:type: LabelRelation
			.def_readwrite("stereoRelation", &LabelSettings::stereoRelation);

	// rst: .. class:: IsomorphismPolicy
	// rst:
	// rst:		For some functions there is a choice of how to handle given arguments
	// rst:		where two different objects may be isomorphic. Most notably the case is with graphs (:class:`Graph`).
	// rst:
	py::enum_<IsomorphismPolicy>("IsomorphismPolicy")
			// rst:		.. attribute:: Check
			// rst:
			// rst:			Objects are checked for isomorphism as needed and exceptions are thrown when different objects are isomorphic.
			// rst:			If in doubt, use this.
			.value("Check", IsomorphismPolicy::Check)
					// rst:		.. attribute:: TrustMe
					// rst:
					// rst:			No checks are performed and the function trusts the caller to have performed the equivalent isomorphism checks.
					// rst:			Only use this when you are completely sure that no exceptions would have been thrown if using :attr:`Check`.
					// rst:
					// rst:			.. warning:: Generally the library has undefined behaviour if you use this option
					// rst:				but an exception would have been thrown with :attr:`Check`.
			.value("TrustMe", IsomorphismPolicy::TrustMe);
	py::def("_IsomorphismPolicy__str__", &IsomorphismPolicy_str);

	// rst: .. class:: SmilesClassPolicy
	// rst:
	// rst:		When loading SMILES strings, the class labels can be recorded and mapped into the corresponding
	// rst:		vertices of the loaded graph. This policy dictates what should happen when the same class label
	// rst:		is written on multiple atoms.
	// rst:
	py::enum_<SmilesClassPolicy>("SmilesClassPolicy")
			// rst:		.. attribute:: AllOrNone
			// rst:
			// rst:			If a class label is duplicated, then no labels are mapped to vertices.
			.value("NoneOnDuplicate", SmilesClassPolicy::NoneOnDuplicate)
					// rst:		.. attribute:: ThrowOnDuplicate
					// rst:
					// rst:			If a class label is duplicated, throw a :class:`InputError`.
			.value("ThrowOnDuplicate", SmilesClassPolicy::ThrowOnDuplicate)
					// rst:		.. attribute:: MapUnique
					// rst:
					// rst:			Map all class labels that are unique to vertices.
			.value("MapUnique", SmilesClassPolicy::MapUnique);
	py::def("_SmilesClassPolicy__str__", &SmilesClassPolicy_str);

#define NSIter(rNS, dataNS, tNS)                                                \
         BOOST_PP_SEQ_FOR_EACH_I(SettingIter, ~,                                \
            BOOST_PP_TUPLE_ELEM(MOD_CONFIG_DATA_NS_SIZE(), 2, tNS))
#define SettingIter(rSetting, dataSetting, iSetting, tSetting)                  \
         (BOOST_PP_TUPLE_ELEM(MOD_CONFIG_DATA_SETTING_SIZE(), 0, tSetting))
#undef NSIter
#undef SettingIter

	auto configClass = py::class_<Config, boost::noncopyable>("Config", py::no_init);
	{ // Config scope
		py::scope configScope = configClass;
		py::enum_<Config::IsomorphismAlg>("IsomorphismAlg")
				.value("VF2", mod::Config::IsomorphismAlg::VF2)
				.value("Canon", mod::Config::IsomorphismAlg::Canon)
				.value("SmilesCanonVF2", mod::Config::IsomorphismAlg::SmilesCanonVF2);

#define NSIter(rNS, dataNS, tNS)                                                                        \
   py::class_<Config:: BOOST_PP_TUPLE_ELEM(MOD_CONFIG_DATA_NS_SIZE(), 0, tNS), boost::noncopyable>      \
      (MOD_toString(BOOST_PP_TUPLE_ELEM(MOD_CONFIG_DATA_NS_SIZE(), 0, tNS)), py::no_init)               \
         BOOST_PP_SEQ_FOR_EACH_I(SettingIter,                                                           \
            BOOST_PP_TUPLE_ELEM(MOD_CONFIG_DATA_NS_SIZE(), 0, tNS),                                     \
            BOOST_PP_TUPLE_ELEM(MOD_CONFIG_DATA_NS_SIZE(), 2, tNS))                                     \
      ;
#define SettingIter(rSetting, dataSetting, iSetting, tSetting)                  \
      .add_property(AddConfig(                                                  \
         BOOST_PP_TUPLE_ELEM(MOD_CONFIG_DATA_SETTING_SIZE(), 0, tSetting),      \
         BOOST_PP_TUPLE_ELEM(MOD_CONFIG_DATA_SETTING_SIZE(), 1, tSetting),      \
         dataSetting                                                            \
      ))
#define AddConfig(Type, Name, Class)                                            \
   MOD_toString(Name),                                                          \
   py::make_function([] (Config::Class *c) -> Type {                            \
         return c->Name.get();                                                  \
      },                                                                        \
      py::default_call_policies(),                                              \
      boost::mpl::vector<Type, Config::Class*>()),                              \
   py::make_function([] (Config::Class *c, Type t) -> void {                    \
         c->Name.set(t);                                                        \
      },                                                                        \
      py::default_call_policies(),                                              \
      boost::mpl::vector<void, Config::Class*, Type>())

		BOOST_PP_SEQ_FOR_EACH(NSIter, ~, MOD_CONFIG_DATA())

#undef NSIter
#undef SettingIter
#undef AddConfig

		py::list classNames;
#define NSIter(rNS, dataNS, tNS)                                                \
      classNames.append<std::string>("Config" MOD_toString(BOOST_PP_TUPLE_ELEM(MOD_CONFIG_DATA_NS_SIZE(), 0, tNS)));
		BOOST_PP_SEQ_FOR_EACH(NSIter, ~, MOD_CONFIG_DATA())
#undef NSIter
		configScope.attr("classNames") =
				classNames;
	} // Config scope

#define NSIter(rNS, dataNS, tNS)                                                       \
   .def_readonly(MOD_toString(BOOST_PP_TUPLE_ELEM(MOD_CONFIG_DATA_NS_SIZE(), 1, tNS)), \
      &Config::BOOST_PP_TUPLE_ELEM(MOD_CONFIG_DATA_NS_SIZE(), 1, tNS))

	configClass
			BOOST_PP_SEQ_FOR_EACH(NSIter, ~, MOD_CONFIG_DATA());

#undef NSIter
#undef SettingIter

// rst: .. class:: Config
// rst:
// rst:		This class contains a range of inner classes of config settings. See :doc:`the libMØD documentation</libmod/Config>`.

// rst: .. data:: config
// rst:
// rst:		This variable is initialised to the return value of :func:`getConfig`, i.e., just use this instead of the method.
// rst:
// rst: .. method:: getConfig()
// rst:
// rst:		:returns: the singleton :cpp:class:`Config` instance used by the library.
	py::def("getConfig", &getConfig,
	        py::return_value_policy<py::reference_existing_object>()
	);
}

} // namespace mod::Py
